package net.brainvitamins.kerberos_gssapi;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.net.UnknownHostException;

import org.ietf.jgss.GSSContext;
import org.ietf.jgss.GSSException;
import org.ietf.jgss.GSSManager;
import org.ietf.jgss.GSSName;
import org.ietf.jgss.MessageProp;
import org.ietf.jgss.Oid;

import android.app.Activity;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.util.Log;
import android.view.Menu;
import android.widget.TextView;
import edu.mit.kerberos.SetEnvOperation;

public class MainActivity extends Activity {

	private TextView mainText;

	Handler messageHandler = new Handler() {
		public void handleMessage(Message message) {
			mainText.append(message.toString());
		}
	};

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.activity_main);

		mainText = (TextView) findViewById(R.id.maintext);
		
		mainText.setText("");

		String service = "test/testbed-kdc";
		String hostName = "192.168.0.30"; //can also be a FQDN
		int port = 4444;

		try {
			File localConfigurationFile = new File(getFilesDir()
					+ File.separator + "krb5.conf");

			mainText.append("Initializing local configuration file "
					+ localConfigurationFile.getCanonicalPath().toString() + "\n");
			InputStream in = getContentResolver()
					.openInputStream(
							Uri.parse("content://edu.mit.kerberos.provider/configuration"));

			FileOutputStream out = new FileOutputStream(localConfigurationFile);
			byte buf[] = new byte[1024];
			int len;
			while ((len = in.read(buf)) > 0)
				out.write(buf, 0, len);
			out.close();
			in.close();

			SetEnvOperation.execute("KRB5_CONFIG",
					localConfigurationFile.toString(), messageHandler);

		} catch (IOException e) {
			mainText.append(e.getMessage() + "\n");
		}

		try {
			InputStream in = getContentResolver()
					.openInputStream(
							Uri.parse("content://edu.mit.kerberos.provider/credentials_cache"));
			File localCredentialsCache = File.createTempFile("credentials",
					"cache");
			FileOutputStream out = new FileOutputStream(localCredentialsCache);
			byte buf[] = new byte[1024];
			int len;
			while ((len = in.read(buf)) > 0)
				out.write(buf, 0, len);
			out.close();
			in.close();
			SetEnvOperation.execute("KRB5CCNAME",
					localCredentialsCache.toString(), messageHandler);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		
		new SampleConnection().execute(new SampleConnectionArguments(service,
				hostName, port));
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		// Inflate the menu; this adds items to the action bar if it is present.
		getMenuInflater().inflate(R.menu.activity_main, menu);
		return true;
	}

	class SampleConnectionArguments {
		final String service;
		final String hostName;
		final int port;

		public SampleConnectionArguments(String service, String hostName,
				int port) {
			this.service = service;
			this.hostName = hostName;
			this.port = port;
		}
	}
	
	class SampleConnection extends
			AsyncTask<SampleConnectionArguments, Void, Void> {

		private Exception exception;

		protected Void doInBackground(SampleConnectionArguments... params) {
			try {
				Socket socket;
				socket = new Socket(params[0].hostName, params[0].port);
				DataInputStream inStream = new DataInputStream(
						socket.getInputStream());
				DataOutputStream outStream = new DataOutputStream(
						socket.getOutputStream());
				Log("Connected to server " + socket.getInetAddress());

				GSSManager manager = GSSManager.getInstance();
				try {
					GSSName serverName;
					serverName = manager.createName(params[0].service, null);
					Oid krb5Oid = new Oid("1.2.840.113554.1.2.2");

					GSSContext context = manager.createContext(serverName,
							krb5Oid, null, GSSContext.DEFAULT_LIFETIME);

					context.requestMutualAuth(true);
					context.requestConf(true);
					context.requestInteg(true);

					// Do the context establishment loop
					byte[] token = new byte[0];

					while (!context.isEstablished()) {

						// token is ignored on the first call
						token = context.initSecContext(token, 0, token.length);

						// Send a token to the server if one was generated by
						// initSecContext
						if (token != null) {
							Log("Will send token of size "
									+ token.length + " from initSecContext.");
							outStream.writeInt(token.length);
							outStream.write(token);
							outStream.flush();
						}

						// If the client is done with context establishment
						// then there will be no more tokens to read in this
						// loop
						if (!context.isEstablished()) {
							token = new byte[inStream.readInt()];
							Log("Will read input token of size "
									+ token.length
									+ " for processing by initSecContext");
							inStream.readFully(token);
						}
					}

					Log("Context Established! ");
					Log("Client is " + context.getSrcName());
					Log("Server is " + context.getTargName());

					/*
					 * If mutual authentication did not take place, then only
					 * the client was authenticated to the server. Otherwise,
					 * both client and server were authenticated to each other.
					 */
					if (context.getMutualAuthState())
						Log("Mutual authentication took place!");

					byte[] messageBytes = "Hello There!\0".getBytes();

					/*
					 * The first MessageProp argument is 0 to request the
					 * default Quality-of-Protection. The second argument is
					 * true to request privacy (encryption of the message).
					 */
					MessageProp prop = new MessageProp(0, true);

					/*
					 * Encrypt the data and send it across. Integrity protection
					 * is always applied, irrespective of confidentiality (i.e.,
					 * encryption). You can use the same token (byte array) as
					 * that used when establishing the context.
					 */

					byte[] messagetoken = context.wrap(messageBytes, 0,
							messageBytes.length, prop);
					Log("Will send wrap token of size "
							+ messagetoken.length);
					outStream.writeInt(messagetoken.length);
					outStream.write(messagetoken);
					outStream.flush();

					/*
					 * Now we will allow the server to decrypt the message,
					 * calculate a MIC on the decrypted message and send it back
					 * to us for verification. This is unnecessary, but done
					 * here for illustration.
					 */

					token = new byte[inStream.readInt()];
					Log("Will read token of size " + token.length);
					inStream.readFully(token);
					context.verifyMIC(token, 0, token.length, messageBytes, 0,
							messageBytes.length, prop);

					Log("Verified received MIC for message.");

					Log("Exiting...");

					context.dispose();
					socket.close();
				} catch (GSSException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

			} catch (UnknownHostException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}

			return null;
		}
		
		public void Log(final String message)
		{
			runOnUiThread(new Runnable() {
				public void run() {
					mainText.append(message + "\n");
				}
			});
		}
	}
}
